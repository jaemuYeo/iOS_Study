# 학습 내용

## 프로세서와 프로세스

### 프로세서

- 하드웨어적 측면

  - 컴퓨터 내에서 프로그램을 수행하는 하두웨어 유닛
  - CPU를 뜻하며, 적어도 하나 이상의 연산처리장치와 처리 레지스터를 내장하고 있다.

- 소프트웨어적 측면

  - 데이터 포맷을 변환하는 역할을 수행하는 데이터 프로세싱 시스템(데이터 처리 시스템)

    (ex - 워드프로세서, 컴파일러 등등)

### 프로세스

메모리에 적재되어 실행 중이거나 대기 중인 `프로그램`

---

## 활동학습 과제 (With 타코켓, 코든, 승기)

### 1. Windows 운영체제는 32bit 버전, 64bit 버전, ARM 버전 등 다양한 버전이 존재합니다. 이 버전은 어떤 것을 의미하며 왜 이렇게 다양한 버전이 존재해야 할까요?

- 32bit, 64bit → CPU 레지스터가 가질 수 있는 최대 bit(word)
  - word
  - 레지스터 - 요청을 처리하는 데 필요한 데이터를 일시적으로 저장하는 기억장치
    - CPU와 직접연결, 연산 속도가 메모리보다 실제 수십 배에서 수백 배까지 빠르다.
- CPU bit와 메모리의 크기

  → 32비트의 경우 2의 32승개의 정보를 표현할 수 있음 즉 4GB의 주소에 접근 가능 따라서 메모리 용량 한계는 4GB, 한번에 4바이트씩 연산

  → 64비트 : 16 XB 의주소에 접근 가능(하지만 실제는 이보다 적음) , 한번에 8바이트씩 연산

- ARM 버전 : CPU의 한 종류

  - **`RISC`아키텍쳐 방식을 사용**
  - 참고

- 이 버전은 어떤 것을 의미하며 왜 이렇게 다양한 버전이 존재해야 할까요?
  - **`다다익램`**
  - 실행해야하는 프로그램이 달라서
  - 메모리크기 증대가 요구됨에 따라 이에 맞춰서 CPU의 레지스터 word크기도 변화?
  - 필요한 사용처가 달라서
    - ARM은 내부 구조를 수정할 수 있기 때문에 해당 라이센스를 가지고 다양한 형태의 프로세서를 만들 수 있지 않을까..?

### 2. 내 매킨토시의 프로세서는 무엇인가요?

- 코든 - m1
- 승기 - 4코어 intel coRE i5
- 잼킹 - 2.6 GHz 6코어 Intel Core i7
- 타코캣 - m1

### 3. 애플이 새로 출시한 매킨토시 컴퓨터에서 iOS의 애플리케이션을 실행할 수 있는 이유는 무엇일까요?

- M1칩이 `ARM` 기반이여서 iOS 와 호환이 가능하다

  = 두 프로세서의 **instruction set**이 같다 (set이 다르면 컴파일을 다시해야 하기 때문에)

  = 같은 ARM 아키텍처 기반이며, RISC 중에서도 동일한 Instruction Set을 사용하기 때문에 호환이 된다.

  - `Instruction Set` : 'CPU에 작업을 시키는 명령어' 세트

- Big sur는 m1용과 intel용으로 각각 컴파일되어 만들어져 있을 것 (= bug가 많을 수 밖에 없게 된다. )

  = 명령어 세트가 같아지면 어떤 환경에서도 실행 가능해진다. m1칩은 ARM기반이기 때문에 해당 명령어를 실행할 수 있다. 하지만 인텔 맥북에서는 실행할 수 없다.

- 시뮬레이터는 시뮬레이터 전용으로 빌드가 된 것일뿐 ARM 아키텍처로 컴파일 된 것은 아니다. (앱스토어에 올라간 것들은 ARM 아키텍처로 컴파일된 것들)

### 4. 이전의 매킨토시 컴퓨터에서는 불가능했던 이유는 무엇일까요?

- `ISA`가 달라서

  - ISA : Instruction set architecture
    - software 에서 Hardware 로 넘어가는 단계에서 중재자 역할을 해주는 것
    - ISA는 최하위 레벨의 프로그래밍 인터페이스로, `프로세서가 실행할 수 있는 모든 명령어`들을 포함한다.

- 참고문서

  [https://velog.io/@shinychan95/컴퓨터-구조-2강-정리-feat.-ISA](https://velog.io/@shinychan95/%EC%BB%B4%ED%93%A8%ED%84%B0-%EA%B5%AC%EC%A1%B0-2%EA%B0%95-%EC%A0%95%EB%A6%AC-feat.-ISA)

  [http://melonicedlatte.com/computerarchitecture/2019/01/30/192433.html](http://melonicedlatte.com/computerarchitecture/2019/01/30/192433.html)

```
iOS환경을 위해 컴파일된 어플리케이션은 해당 ARM 아키텍쳐(RISC)의 Instruction set에 따른 기계어 코드를 갖는다. 인텔기반의 기존 맥(CISC)에서는 다른 Instruction Set을 가지고 있고 때문에 해당 기계어들을 올바른 Instruction Set으로 인식하지 못한다. 하지만 ***m1이 생기면서 같은 Instruction Set을 가지게 되었고, 덕분에 기계어를 동일한 명령어로 인식할 수 있게 되었다.***
```

- [CISC](https://en.wikipedia.org/wiki/Complex_instruction_set_computer)

  - Complex instruction Set computer,명령어 세트가 복잡함

- **`RISC`**

- RISC : 상대적으로 적은 수의 명령어를 가짐, 명령어들의 복잡도를 줄임. 하드웨어 보다는 소프트웨어의

  유연성과 기능성을 제공, 컴파일러에 더욱 의존

- 32-bit-RISC프로세서 CPU로서 instruction set이 간단
- 전력소모가 적음, 성능에 따라 다양한 CPU제공
- 사용자에 특화된 Chip 생산 가능
- 라이센스에 따라 내부구조에 대한 수정 가능
- 휴대용 모바일기기에 많이 사용됨 - Window10에도 쓰임
- CPU와 메모리가 붙어있는 `SoC` 형태의 프로세서
  - System on chip
- **같은 Swift코드여도 프로세서에 따라 다른 기계어로 번역된다. (Instruction Set이 달라서)**
- 같은 ARM기반이어도 ISA가 다를 수 있다. 왜냐하면 ARM은 오픈소스이기 때문에( = 변경할 수 있다는 뜻)
- 같은 ARM 아키텍처 기반이며, RISC 중에서도 동일한 Instruction Set을 사용하기 때문에 호환이 된다.

### 5. 프로세서를 위한 프로세스 스케쥴링 방식에는 어떤 것이 있는지 간략히 알아봅시다.

- **선점형**

  - `Round Robin`

    CPU를 줄 때는 할당 시간을 셋팅해서 넘겨주고 그 시간이 끝나면 타이머 인터럽트가 걸려 CPU를 빼앗기는 것

  - `SRTF`(Shortest Remaining Time First)

    프로세스 실행 중 더 적은 CPU 작업 시간을 요구하는 프로세스가 들어오면 현재 실행중인 프로세스를 멈추고 새로 들어온 프로세스를 실행

- **비선점형**

  - `FCFS`(Frst-Come First-Served)

    먼저 온 순서대로 처리한다.

  - `SJF`(Shortest-Job-First)

    CPU를 사용하고자 하는 CPU 버스트가 제일 짧은 프로그램한테 CPU사용권을 주는 것.

- **선점과 비선점 둘다 구현 가능**

  - `Priority Based Scheduling`

    우선순위가 제일 높은 프로세스에게 CPU를 주는 개념

  - [`MultiLevelQueue](https://www.geeksforgeeks.org/multilevel-queue-mlq-cpu-scheduling/.) Scheduling`

    CPU는 위에 순서(우선순위가 높은)부터 큐의 작업을 먼저 처리하는 스케쥴링 방식

  - `MultiLevelFeedback Queue Scheduling`

    CPU 사용시간이 짧은 프로세스한테 우선순위를 많이 주는 스케줄링 방식.

    CPU의 사용시간이 긴 프로세스는 우선순위가 낮은 큐로 점점 이동하게 됨

- **그 외**

  - `Multiple-Processor 스케줄링`

    CPU가 여러 개인 경우이거나 시간에 대한 데드라인 제약 조건이 있거나 스레드가 여러개 있는 경우에

    대한 CPU 스케줄링 방식

  - `Real-Time 스케줄링`

    데드라인이 있는 보장받아야하는 스케줄링이다.

  - `Thread 스케줄링`
    - Local 스케줄링, Global 스케줄링

### 6. 운영체제 입장에서 다양한 프로세스를 스케쥴링하는 규칙을 만들어봅시다.

- 우선순위를 설정해서 중요한 것부터 처리하도록 한다
  - 사용시간이 짧으면 우선순위를 높게 준다
- CPU선점시간이 짧은 것에 먼저 CPU사용권을 준다.
- 공유하는 메모리 영역에 접근하는 경우 먼저 사용하고 있는 process가 수정이 끝날 때 까지 접근하지 못하도록 한다
- 프로그램 설치를 할 때마다 사용자가 직접 우선순위를 부여하고, 이에따라 스케쥴링 되는 방법
- 작업시간이 짧은 것 부터 처리한다.

### 7. 앞으로 iOS와 macOS는 통합될까요?

코든 - OS 자체가 통합되지는 않을 것 같다. 일단 구동환경이 다르기때문에

승기 -할꺼같다~~

잼킹 - 애플 `돈독`올라서 절대 통합안함 ㅎ UI적인 문제만 해결하면 기술적으로는 가능할거 같습니다

타코캣 - macOS와 패드는 통합 될 것 같다.

---

## Content Hugging (CH) & Compression Resistance (CR)

<img width="466" alt="스크린샷 2021-02-13 오후 9 56 22" src="https://user-images.githubusercontent.com/70311145/107850515-56535500-6e46-11eb-89db-36a4c101e1d2.png">

두개의 속성을 보면 Priority가 붙어 있는데 위에서 보았던 제약의 우선순위처럼

1000에서 1사이의 값으로 지정할 수 있는 우선순위이다.

<img width="258" alt="스크린샷 2021-02-13 오후 9 12 02" src="https://user-images.githubusercontent.com/70311145/107849663-23a65e00-6e40-11eb-92ca-50147879c78c.png">

이 우선순위는 뷰를 배치할 수 있는 공간의 크기가 Intrinsic Size와 다를 때

너비와 높이 값이 커지거나 작아지는 우선순위를 지정한다.

CH와 CR 모두 수평과 수직 방향으로 하나씩 우선순위를 지정할 수 있고,

CH의 기본 값은 250 CR의 기본 값은 750이다.

Intrinsic Size를 가진 뷰가 동일 선상에 두개 이상 배치되어 있을 때 의미를 가지게 된다.

- Content Hugging - 프레임 확장에 대한 저항력

  - 늘어나지 않으려고 버티는 힘.

  CH의 우선 순위가 1000이라면 가장 높은 저항력을 가지는 것이고,

  어떠한 경우에도 너비나 높이가 Intrinsic Size를 초과하지 않는다.

  우선 순위가 낮아질수록 저항력도 낮아지고, Intrinsic Size를 초과할 가능성이 높아진다.

아래에는 Label과 TextField의 제약에 추가되어 배치되어있다.

현재 Intrinsic Size와 CH를 통해 계산된 너비를 가지고 있다.

현재 Label의 CH 값이 251, TextField의 CH 값이 250이로 설정되어 있어서

프레임 확장에 대한 저항력이 더 높은 Label이 Intrinsic Size로 표시되고,

상대적으로 낮은 TextField가 확장되어서 나머지 영역을 채우게 된다.

<img width="279" alt="스크린샷 2021-02-13 오후 9 24 07" src="https://user-images.githubusercontent.com/70311145/107849944-d4612d00-6e41-11eb-959d-d031746bb556.png">

TextField의 CH값을 260으로 바꾸게 되면 프레임 확장에 대한 저항력이 Label보다 높아지고

TextField는 Intrinsic Size로 표시되고, Label이 나머지 영역을 채운다.

<img width="276" alt="스크린샷 2021-02-13 오후 9 28 37" src="https://user-images.githubusercontent.com/70311145/107849999-7719ab80-6e42-11eb-8529-31438e454f11.png">

혹여나 두 우선순위의 값이 같으면 제약 오류가 발생하고, 이 오류를 해결하는 방법으로는

width을 추가하거나 Label과 TextField의 너비를 같게 만드는 Equal width 제약을 추가하는 것이다.

- Compression Resistance - 프레임 축소에 대한 저항력

  - 외부에서 압력을 줄 때 버티는 힘.

  우선 순위가 1000으로 지정되어 있다면 어떤 경우에도 클리핑 없이 표시되지만

  우선 순위가 낮아질 수록 프레임 축소에 대한 저항력이 낮아서

  클리핑이 발생할 수도 있고, 경우에 따라 제약 오류가 발생한다.

CR의 우선순위와 Width의 우선순위가 동일하다면 CR이 더 높은 우선순위를 가지게 된다.

코드를 통해 동적으로 변경하는 경우에는 우선순위 지정에 주의해야한다.

**UI를 설계할 때에는 되도록이면 CH, CR을 함께 고려해야하는 경우가 없도록해야한다.**

---

## 오늘의 문제

1. ARC는 자동으로 다 해주니까 특별한 규칙은 몰라도 된다. `False!!``

   - 메모리에서 해제하고 메모리에 할당하는 코드를 자동으로 넣고, 자동으로 레퍼런스 카운팅을 해주는 것뿐

     규칙을 모르고 있으면 안된다.

2. 메모리 영역 중 ARC와 관련된 영역은? `Heap`

   - 메모리를 동적으로 할당하고 해제하는 것은 Heap영역에서 일어난다.

3. 인스턴스 메모리의 Heap 영역에 할당되는 타입은? `Class`

   - ARC가 작동하는 것은 Class 이다. 구조체나 열거형은 참조가 아닌 값이 복사되는 것!

4. ARC를 통한 인스턴스 생명주기는 런타임에 결정된다. `Flase`

   - ARC는 이미 컴파일 할 때부터 어느 시점에 메모리에서 해제되겠다를 규칙에 따라 알고있기때문에

     생명주기는 `컴파일` 시점에 결정된다.

5. 동시성(Concurrency)은 논리적 개념, 병렬성(Parallelism)은 물리적 개념이다. `True``

   - 동시성 - 코어가 하나라도 빠르게 작업을 처리하여 동시에 하는 것 처럼 보이는 것.

   - 병렬성 - 코어가 여러개 있을 때 여러 코어가 일을 분할하여 수행하는 것.

6. 병렬처리는 멀티코어 환경에서만 가능하다. `True`

7. 멀티코어 환경은 물리적 환경이므로 동시성 프로그래밍과 상관없다 `False`

   - 코어가 여러개라도 스레드들이 여러 코어에 나뉘어서 작업을 빠르게 처리한다.

8. 스위프트 타입의 모든 프로퍼티는 Thread-safe하다. `False`

   - Thread-safe란? - 읽고 쓰기에 대한 동시에 접근을했을 때에도 안전하다.

   여러스레드가 동시에 접근하는 것을 막는 처리를 해주어야 한다.

   - Lock을 걸고 Unlock을 처리해줘야 Thread-safe해진다.

9. 스위프트 타입의 모든 프로퍼티는 atomic하다. `False`

   - Thread-safe하다 == atomic하다.

10. 두 개 이상의 프로세스나 스레드가 하나의 데이터를 공유할 때 데이터가 동기화되지 않는 상황을 뜻하는 용어는?

    `Race Condition` - 읽고 쓰러는 행위를 할때 동시에 접근해버리는 경우 발생.

    Race condition을 방지하기 위해 뮤텍스와 세마포어를 사용한다.
