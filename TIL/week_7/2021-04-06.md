# 학습활동

정보를 효율적이고 안전하게 저장하기 위해 `인코딩`과정을 거쳐, 정보를 표준화 및 암호화한다.

이 데이터를 다시 원래 객체의 모습으로 돌리는 과정을 `디코딩`이라고 한다.

Swift는 인코딩과 디코딩을 위한 프로토콜로 (Encodable, Decodable)이 있으며,

두 프로토콜을 함께 사용하는 경우 Codable 프로토콜을 사용하면 된다.

## Codable (Encoder, Decoder)

자신을 변환하거나 외부표현(JSON)으로 변환 할 수 있는 타입이다.

```swift
typealias Codable = Decodable & Encodable
```

Codable은 위 선언 처럼 디코딩과 인코딩이 모두 가능한 프로토콜이다.

- String, Int 및 Double과 같은 많은 표준 라이브러리 타입은 기본적으로 Codable을 준수한다.
- Date, Data 및 URL과 같은 몇가지 재단 타입도 확인한다.
- 컬렉션 및 매핑 가능한 타입(Array, Dictionary 및 Optional)은
  콘텐츠도 Codable을 준수 할 때 자동으로 Codable을 준수한다.
- 커스텀 타입이 모두 Codable을 준수하는 프로퍼티로 구성되면 커스텀 타입도 자동으로
  적절한 선언을 준수한다.
- 커스텀 Codable 형식은 구조체 또는 클래스로 정의 할 수 있다.

```swift
struct Fruit {
    var name: String
    var amount: Int
    var price: Int
}

struct Fruit: Codable {
    var name: String
    var amount: Int
    var price: Int
}
```

### 인코딩 방법

```swift
let encoder = JSONEncoder()
// Fruit 타입 인스턴스 생성
let order = Fruit(name: "Melon", amount: 1, price: 2000)

let jsonEncoder = try? encoder.encode(order)

if let jsonEncoder = jsonEncoder, let jsonString = String(data: jsonData, encoding: .utf8) {
    print(jsonString)
}

/*
{
    "name" : "Melon",
    "amount" : 1,
    "price" : 2000
}
*/
```

encoder의 encode 메서드에 Fruit 타입의 인스턴스를 넣어준다.

encode안에 올 수 있는 값은 Encodable을 준수하고 있는 타입이어야 한다.

인코딩 중에 에러를 발생시킬 수 있기 때문에 try를 반드시 써줘야 한다.

```swift
// 또는
let order = Fruit(name: "Melon", amount: 1, price: 2000)
let jsonEncoder = JSONEncoder()
jsonEncoder.outputFormatting = .prettyPrinted

do {
    let data = try jsonEncoder.encode(order)
    print(String(data: data, encoding: .utf8)!)
} catch {
    print(error)
}
// 이번 프로젝트에서 느낌표는 피해야해서 사용하지 않을 예정
```

### 디코딩 방법(데이터 파싱)

```swift
{
    "name" : "Melon",
    "amount" : 1,
    "price" : 2000
}

let decoder = JSONDecoder()
var data = jsonString.data(using: .utf8)

if let data = data, let orderFruit = try? decoder.cecode(Fruit.self, from: data) {
    print(orderFruit.name)
    print(orderFruit.amount)
    print(orderFruit.price)
}
```

인코딩한 방법을 반대로 한다고 생각하면 된다.

### CodingKey

JSON 형태의 데이터로 변환하거나 파싱을 할 때 기본적으로 JSON타입의 키와 사용자가 정의한

프로퍼티가 일치해야 한다. 이때 키와 프로퍼티의 이름을 다르게 사용하고 싶다면

CodingKey라는 String 타입의 열거형을 선언하고 `CodingKey` 프로토콜을 준수하게 만들어야한다.

**Note** 프로퍼티를 생략 할 때 Codable을 자동으로 준수하려면 이니셜라이저에 기본값을 제공해야한다.

스네이크 케이스 사용

```swift
// case로 모든 프로퍼티의 이름에 대해 key를 새로 배정할 수 있음
// 그대로 사용하고 싶은 프로퍼티는 이름을 할당하지 않으면 된다.

struct Person: Codable {
    var name: String
    var age: Int
    var adress: String

    enum CodingKeys: String, CodingKey {
        case name = "full_name"
        case age
        case adress = "residence"
    }
}
```
