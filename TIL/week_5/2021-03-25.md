# Swift 데이터 구조 (Stack)

스택은 배열과 비슷하지만 기능이 제한된다.

Push하여 스택 맨 위에 새 요소를 추가하고, Pop하여 맨 위에서 요소를 제거하고,

맨 위에 있는 요소를 튀어 나오지 않고 Peek할 수만 있다.

---

## 왜 스택을 사용할까?

알고리즘에서는 어떤 시점에서 임시 목록에 Object를 추가 한 다음

나중에 이 목록에서 다시 가져 오려고 한다. 종종 이러한 개체를 추가하고, 제거하는 순서가 중요하다.

스택은 `LIFO(Last-In-First-Out)` 또는 `후입선출`을 제공한다.

마지막으로 밀었던 요소는 다음 Pop에서 가장 먼저 떠오르는 요소이다.

스택 구축의 주요 목표는 데이터 접근 방식을 적용하는 것이다.

- iOS는 네비게이션 스택을 사용하여 뷰컨트롤러 안팎으로 Push & Pop한다.

- 메모리 할당은 아키텍처 수준에서 스택을 사용한다.

  지역 변수의 메모리도 스택을 사용하여 관리된다.

- 미로에서 경로를 찾는 것과 같은 Search 및 Conquer 알고리즘은 스택을 사용하여

  역 추적을 용이하게 한다.

---

스택은 기능의 범위가 비교적 제한적이다.

햄버거 패티로 예를 들어보면

### Push

스택에 요소를 추가하려면 스택에 Push한다.

'제일 아래 참깨빵이 있고 위에 양상추를 올린다.'

### Peek

의도적으로 스택은 스택의 맨 위 요소를 제외하고 내용을 확인할 수 없다.

Peek 메서드를 사용하면 스택 맨 위에있는 항목을 `확인`할 수 있다.

'양상추가 있군!'

### Pop

스택에서 요소를 제거하려면 스택에서 요소를 Pop한다.

'생각해보니 패티를 먼저 올려야 할것 같아 양상추를 뺀다.'

---

## Swift Stack Implementation

```swift
struct Stack {
    var array: [String] = []
}
```

array 프로퍼티가 있는 Stack 구조체를 선언했다.

Push, Pop 및 Peek 메서드를 구현하기 위해 배열과 상호작용 하게된다.

### Push

객체를 스택에 밀어 넣는 것은 비교적 간단하다.

```swift
mutating func push(_ element: Stirng) {
    array.append(elemet)
}
```

1. Push 메서드는 스택 맨 위에 추가 할 요소인 단일 매개변수를 사용한다.

2. Push 작업은 새 요소를 시작이 아닌 배열의 끝에 배치한다.

   배열의 시작 부분에 삽입하는 것은 기존의 모든 배열 요소를 메모리에서

   이동해야 하므로 O(n) 연산으로 비용이 많이든다.

   끝에 추가하는 것은 O(1) 배열의 크기에 관계없이 항ㅅ아 동일한 시간이 걸린다.

### Pop

```swift
mutating func pop() -> String? {
    return array.popLast()
}
```

1. Pop 메서드는 옵셔널 Stirng을 반환한다. 반환 타입은 스택이 처음에 비어있는 경우를

   처리하기 위해 옵셔널 사항이다. 빈 스택을 Pop하려고 하면 nil이 표시된다.

2. Swift 배열에는 마지막 요소를 제거하는 편리한 방법이 있다. PopLast가 그 방법이다.

### Peek

스택을 들여다 보는 것은 스택의 맨 위 요소를 확인하는 것이다.

이것은 비교적 간단해야한다. Swift 배열에는 자체 변경없이 마지막 요소를 반환하는

마지막 속성이 있다.

```swift
func peek() -> Stirng? {
    return array.last
}
```

Peek 메서드는 Pop 메서드와 매우 유사다하. 이름 외에 유일한 차이점은

Peek은 배열의 내용을 변경하지 않기 때문에 mutating키워드를 붙이지 않는다.

### 실 사용 예제

```swift
var hamburger = Stack()

hamburger.push("참깨빵")

hamburger.peek()

hamburger.pop()

hamburger.pop()
```

hamburger 프로퍼티를 선언하고 Stack으로 초기화 했다.

스택의 내용을 변경해야 하므로 상수가 아닌 변수로 선언하여아 한다.

스택을 Peek하게 되면 마지막으로 넣은 요소인 "참깨빵"을 알려준다.

주문이 취소되어 pop을 하게되면 마지막으로 넣은 요소인 "참깨빵"을 알려준다.

두번째 pop에는 이미 주문이 취소되어 재료를 모두 정리하여 nil을 산출한다.

---

## CustomStringConvertible

위의 예제 스택에서 어떤 요소가 있는지 시각화하는 것은 매우 어렵다.

Swift는 CustomStringConvertible 프로토콜이 내장되어 있어

객체를 문자열로 표현하는 방법을 정의할 수 있다.

```swift
Extension Stack: CustomStringConvertible {
    var baseBread: Stirng {
        let topDivider = "---참깨빵---\n"
        let bottomDivider = "\n---참깨빵---\n"

        let stackElements = array.reversed().joined(separator: "\n")
        return totDivider + stackElements + bottomDivider
    }
    var 불고기버거 = Stack()
    불고기버기.push(소스)
    불고기버기.push(양상추)
    불고기버기.push(불고기패티)
    불고기버기.push(치즈)
    print(불고기버거)
}

---참깨빵---
치즈
불고기패티
양상추
소스
---참깨빵---
```

\n은 줄 바꿈 구분 기호라고하며, 새 줄을 만들 겠다는 것을 시스템에게 알린다.

스택의 요소를 표시하기 위해 배열의 요소를 reversed한다.

배읠의 뒷면에 요소를 추가 했으므로 먼저 배열을 반전해야 한다. 그 후 joined(separator:) 메서드는

단순히 배열의 보든 요소를 가져와서 모든 요소 사이의 구분 기호와 함께 연결한다.

마지막으로 스택 요소를 두 Divider 사이에 끼우고 결과를 스택에 대한 설명으로 retrun 한다.

---

## 제네릭활용 Stack

위 예제에서는 문자열만 저장하는 스택이였다.

스택을 생성하여 정수를 저장하려면 정수에 맞춰 완전 새로운 스택을 구현해야한다.

Swift는 제네릭을 통해 모든 타입을 받을 수 있다.

```swift
struct Stack<Element> {
    var array: [Element] = []

    mutating func push(_ element: Element) {
        array.append(element)
    }

    mutating func pop() -> Element? {
        return array.popLast()
    }

    func peek() -> Element? {
        return array.last
    }
}
```

위에 Extension으로 주었던 stackElements 상수를 지금 정의된 Stack이라고 생각하면

한가지만 변경하면 된다.

```swift
// 위의 예제
let stackElements = array.reversed().joined(separator: "\n")
// 현재 예제
let stackElements = array.map { "\($0)"
}.reversed().joined(separator: "\n")
```

여기서의 생각은 배열의 요소를 결합하기 전에 문자열로 변환하는 것이다.

스택이 이제 제네릭이므로 결합하는 값이 문자열인지 확신할 수 없다.

마지막으로 스택을 초기화하고 문자열을 입력하도록 스택을 전문화해주면 된다.

```swift
var hamburger = Stack<String>()
```

이제 스택은 String, Int 또는 Person 객체와 같이 사용자가 만든 커스텀 타입이든 상관없이

모든 타입에 특화 될 수 있다!!

### 마무리 작업

스택과 함께 제공되는 다른 두 가지 속성이 있다.

종종 스택이 비어 있는지 여부와 현제 스택에 있는 요소의 수를 알고 싶을 수 있다.

```swift
var isEmpty: Bool {
    return array.isEmpty
}

var count: Int {
    return array.count
}
```

[참고자료1](https://www.raywenderlich.com/800-swift-algorithm-club-swift-stack-data-structure#toc-anchor-006)

[참고자료2](https://www.raywenderlich.com/books/data-structures-algorithms-in-swift/v3.0/chapters/4-stack-data-structure)
