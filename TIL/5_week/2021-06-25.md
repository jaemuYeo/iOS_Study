# 학습 내용

## 시간 복잡도

며칠전 프로젝트를 진행하다 코든과 조스트가 시간복잡도에 대해 이야기하는 것을 듣고

예전에 한번 훑고 지나갔던 내용들을 공부해보아야겠다는 생각이 들었다.

[유튜브강의](https://www.youtube.com/watch?v=6Iq5iMCVsXA&t=148s)

[예전공부자료](https://jaemuyeo.github.io/cs50/cs50-4/)

[사진 출처](https://cooervo.github.io/Algorithms-DataStructures-BigONotation/index.html)

[참고블로그](https://velog.io/@leobit/자료구조Data-Structure)

### 알고리즘

- 어떤 목적을 달성하거나 결과물을 만들어내기 위해 거쳐야 하는 일련의 과정들
- 문제를 해결하기 위한 여러 동작들의 모임
- 여러가지 상황에 따른 알고리즘은 모두 다르다. 따라서 시간 복잡도가 가장 낮은 알고리즘을 선택하여 사용한다.

`알고리즘 실행시간은 컴퓨터가 알고리즘 코드를 실행하는 속도에 의존한다`

이 속도는 컴퓨터의 처리속도, 사용된 언어종류, 컴파일러의 속도에 달렸다.

### 좋은 알고리즘 분석 기준

- Correctness : 문제를 해결하는가

- Efficiency : 이를 효과적으로 하는가

  - 정확성, 작업량, 기억 장소 사용량, 최적성, `복잡도(Big O 표기법 = 점근표기법)`

입력값의 크기에 따른 함수의 증가량, 우리는 이것을 성장률이라고 부른다.

이때 중요하지 않는 상수와 계수들을 제거하면 알고리즘의 실행시간에서 중요한

성장률에 집중할 수있는데 이것을 점금적 표기법(Asymptotic notation)이라 부른다.

점근적 - 가장 큰 영향을 주는 항만 계산한다는 의미한다.

점근적 표기법 세가지 종류는 시간복잡도를 나타내는데 사용된다.

- 최상의 경우 : 오메가 표기법 (Big-Ω Notation)
- 평균의 경우 : 세타 표기법 (Big-θ Notation)
- 최악의 경우 : 빅오 표기법 (Big-O Notation)

세타 표기를 하면 가장 정확하고 좋겠지만 평가하기가 까다롭다.

그래서 최악의 경우인 빅오를 사용하는며 이 최악인 경우를 판단하면 평균과 가까운

성능으로 예측하기 쉽기때문에 빅오표기법을 사용한다.

### 시간 복잡도 이해하기

시간복잡도의 가장 간단한 정의는 알고리즘의 성능을 설명하는 것이다.

`알고리즘을 수행하기 위해 프로세스가 수행해야하는 연산을 수치화 한것`

<img width="829" alt="스크린샷 2021-06-26 오전 1 38 16" src="https://user-images.githubusercontent.com/70311145/123458955-9ad6d480-d620-11eb-8d88-c05390cb19c8.png">

<img width="405" alt="스크린샷 2021-06-26 오전 1 55 27" src="https://user-images.githubusercontent.com/70311145/123459697-9bbc3600-d621-11eb-811b-caeaa70c3500.png">

위와 같은 그림을 공식으로 표기한 것이 Big O 표기법이다.

O의 약자는 ‘on the order of’의 약자로, ‘~ 만큼의 정도로 커지는’것이다.

O(n)은 n만큼 커지는 것이므로 n이 늘어날수록 선형적으로 증가하게 된다.

O(n/2)도 결국 n이 매우 커지면 1/2은 큰 의미가 없어지므로 O(n)이라고 볼 수 있다.

**실행시간의 상한이 낮은 알고리즘이 더 좋을까, 하한이 낮은 알고리즘이 더 좋을까?**

- 최악의 상황에서의 시간 단축이 더 중요하므로 상한이 낮은 알고리즘이 더 좋다.

시간복잡도에서 중요하게 보는것은 가장큰 영향을 미치는 n의 단위이다.

- O(1) – 상수 시간 : 문제를 해결하는데 오직 한 단계만 처리함.

  ex) 배열에서 특정 인덱스 찾기, 해시테이블 추가

- O(log n) – 로그 시간 : 문제를 해결하는데 필요한 단계들이 연산마다 특정 요인에 의해 줄어듬.

  ex) 이진 탐색

- O(n) – 직선적 시간 : 문제를 해결하기 위한 단계의 수와 입력값 n이 1:1 관계를 가짐.

  ex) 연결 리스트 순회, 최대값 찾기

- O(n log n) : 문제를 해결하기 위한 단계의 수가 N\*(log2N) 번만큼의 수행시간을 가진다. (선형로그형)

  ex) 퀵 정렬, 병합정렬 등

- O(n^2) – 2차 시간 : 문제를 해결하기 위한 단계의 수는 입력값 n의 제곱.

  ex) 버블 정렬, 삽입 정렬

- O(C^n) – 지수 시간 : 문제를 해결하기 위한 단계의 수는 주어진 상수값 C 의 n 제곱.

  ex) 최악의 시간복잡도, recursion

### 시간복잡도를 구하는 요령

- 하나의 루프를 사용하여 단일 요소 집합을 반복 하는 경우 : O (n)
- 컬렉션의 절반 이상 을 반복 하는 경우 : O (n / 2) -> O (n)
- 두 개의 다른 루프를 사용하여 두 개의 개별 콜렉션을 반복 할 경우 : O (n + m) -> O (n)
- 두 개의 중첩 루프를 사용하여 단일 컬렉션을 반복하는 경우 : O (n²)
- 두 개의 중첩 루프를 사용하여 두 개의 다른 콜렉션을 반복 할 경우 : O (n \* m) -> O (n²)
- 컬렉션 정렬을 사용하는 경우 : O(n\*log(n))

### 정렬 알고리즘 비교

<img width="1059" alt="스크린샷 2021-06-26 오전 1 54 59" src="https://user-images.githubusercontent.com/70311145/123459702-9ced6300-d621-11eb-90f0-d93cb1f2b232.png">

### 자료구조 비교

<img width="1060" alt="스크린샷 2021-06-26 오전 1 42 55" src="https://user-images.githubusercontent.com/70311145/123458961-9d392e80-d620-11eb-9084-90ba74ac7e2d.png">

계산기 프로젝트에서의 시간 복잡도를 위에 표를 통해 알아보았다 😀

[Swift 시간복잡도에 관한 내용](https://demian-develop.tistory.com/30)

---

## 에러처리

에러처리를 사용하는 간단한 방법은 알고있지만 언제 어떻게 써야하는지 궁금했다.

[이 블로그](https://gwangyonglee.tistory.com/52)를 여러 에러의 처리 경우를 알게되었다.

---

## Result 타입

[공식문서](https://developer.apple.com/documentation/swift/result)

[참고자료](https://github.com/apple/swift-evolution/blob/master/proposals/0235-add-result.md)

API 통신할 때 자주 사용된다고 한다.

성공했을땐 success, 실패해서 error 가 리턴되는 경우엔 Failure.

throws, try 및 catch를 사용하는 Swift의 현재 오류 처리는 명시 적 구문 및 런타임 동작을

통해 오류의 자동 및 동기 처리를 제공한다.

그러나 모든 오류 전파 및 언어 처리를 다루는 데 필요한 유연성이 부족하다고 한다.

Result는 다른 언어 및 Swift 커뮤니티 내에서 수동 전파 및 오류 처리에 일반적으로 사용되는 유형이다.

```swift
// Result타입

public enum Result<Success, Failure> where Failure : Error

public enum Result<Success, Failure: Error> {
    case success(Success), failure(Failure)
}
```

Result는 Generic Enumeration으로 선언되어 있다.

제네릭으로 선언되었다는 것은 형식이 명확하다는 것을 의미한다.

### 계산기 프로젝트에서의 사용

코든을 통해 Result 타입이라는 것을 알게되었다.

후위표현식을 계산해주는 함수에서 반환타입을 Result<Double, ClaculatorError>로 하여

계산에 성공할 경우 success(결과값)을 반환하고, 함수 내부 로직에서 에러가 필요한 경우는

failure를 반환하여 사용하였다.

### Result 타입 장점

- 에러 형식이 명시적으로 선언된다
- 타입 캐스팅 없이 에러 처리가 가능해진다
- 형식 추론을 통해 에러 처리 코드가 단순해진다
- 작업의 결과를 성공과 실패로 명확히 구분 가능하다
- get 메소드로 에러 처리 코드를 더욱 단순하게 구현 가능하다
- 기존 에러 처리 패턴을 완전히 대체하는 것이 아니라 에러를 처리하는 방식이 다양해진 것이다
