# 운영체제 스터디 7회차 (CPU Scheduling1)

## CPU 스케줄링이란?

CPU를 얻고자 하는 프로세스 중에서 (Ready queue) 어떤 프로세스한테 CPU를 줄 것인지 결정하는 메커니즘.

### 스케쥴링의 중요한 두 가지 이슈?

- CPU를 누구한테 줄 것인가?

- 주고나서 계속 쓰게할 것인가? 중간에 뺐어올 것인가?

효율적인 스케줄링은 I/O bound job들 즉 사람과 Interaction 하는 것들이 오래 기다리지 않게 해야한다.

---

## CPU 스케쥴링 알고리즘

1. 비선점형 (nonpreemptive) - 강제로 빼앗지 않음

2. 선점형 (preemptive) - 강제로 빼앗음 `대부분 선점형 사용`

### 성능척도?? (Scheduling Criteria)

**시스템 입장**

- CPU utilization(이용률)

  전체 시간 중에서 CPU가 놀지 않지 않고 일한 시간의 비율을 나타낸다.

  CPU는 가능한 바쁘게 일을 시켜라! (비싼 자원이기 때문에 비율을 높여라!)

- Troughput(처리량)

  주어진 시간 동안에 몇 개의 일을 처리했는가? 완료 했는가?

**프로세스(고객) 입장**

- Turnaround time (소요시간, 반환시간)

  CUP를 사용하러 들어와서 CPU를 얻은 후 다 사용할 때까지 걸린 시간.

- Wating time(대기시간)

  CPU를 쓰고자 순수하게 Ready 큐에 기다린 시간

- Response time(응답 시간)

  CPU를 쓰고자 Ready큐에 들어와서 최초로 CPU를 얻기까지 걸린 시간

**❗️주의할 점**

위에서 말하는 시간의 개념 또는 처리한 프로세스의 개수는

프로세스가 시작해서 종료하는 시점이 아니라 CPU관점만 따지고 있는 것이기에

매번 CPU 버스트를 따져야 한다.

**비유**

내가 식당 사장이라고 했을 때 주방장을 고용해서 얼마나 일을 많이 굴렸는가는 CPU utilization이고

Troughput은 테이블 회전율이다.

고객입장에서 식당에 들어와 다 먹고 나가는 시간을 Turnaround time라고 하고,

손님이 밥을 먹기위해 웨이팅 하는 시간을 Wating time, 주문 후 첫 번째 음식이 나오는 시간까지를 Response time이라 한다.

---

### 알고리즘

- FCFS(Frst-Come First-Served) - 먼저 온 순서대로 처리한다. `비선점형`

  먼저 온 프로세스가 처리 시간이 길면 뒤에 프로세스들의 Wating time이 길어진다.

  먼저 온 친구가 처리 시간이 짧다면 평균 대기 시간이 확연히 줄어든다.

  Convoy effect(호위 효과) - 큐에서 오래 기다리는 현상

- SJF(Shortest-Job-First)

  CPU를 사용하고자 하는 CPU 버스트가 제일 짧은 프로그램한테 CPU사용권을 주는 것

  평균 대기 시간을 최소화하는 알고리즘이다. (제일 짧은)

  비선점형의 경우 더 짧은 프로세스가 도착하더라도 CPU를 선점 중인 프로세스가 내려놓을 때까지 대기한다.

  선점형의 경우 더 짧은 프로세스가 도착하면 CPU를 더 짧은 프로세스에게 양도한다.

  `SJF is optimal은 선점형`

  **문제점**

  1. 기아현상(starvation)

     SJF는 극단적으로 짧은 Job을 선호하므로 사용시간이 긴 프로세스는 영원히 서비스를 받지 못할 수 있다.

  2. CPU 사용시간을 미리 알 수 없다. (추정은 가능)

     Exponential averaging - 과거의 CPU 버스트 타임을 이용해서 추정한다.

---

## 우선순위 스케쥴링(Priority Scheduling)

우선순위가 제일 높은 프로세스에게 CPU를 주는 개념이다.

일반적인 시스템에서는 작은 숫자가 우선순위가 높다.

이 곳에서도 Preemptive와 Nonpreemptive로 나뉜다.

SJF는 일종의 우선순위 스케쥴링이다. 문제점 또한 SJF와 동일한 `starvation`가 있다.

starvation를 해결하기 위해 나온 기법이 Aging(노화) 이다.

- Aging - 오래기다리게 되면 우선순위를 조금씩 높여주는 기법

---

## Round Robin(RR)

현대적인 컴퓨터 시스템에서 사용하는 CPU 스케쥴링은 RR을 기반으로 한다.

CPU를 줄 때는 할당 시간을 셋팅해서 넘겨주고 그 시간이 끝나면 인터럽트가 걸려 CPU를 빼앗기는 것이

바로 이 RR스케쥴링이다.

RR은 프로세스에게 CPU를 줄 때 동일한 시간을 할당해서 주게되고 할당 시간이 끝나면

CPU를 빼앗기고 ready queue의 제일 뒤에가서 다시 줄을 선다.

RR의 장점은 `응답 시간`이 빨라진다는 것이다.

n개의 프로세스가 레디 큐에 있고 할당 시간이 q time unit인 경우 각 프로세스는

최대 q time unit 단위로 CPU tlrksdml 1/n을 얻는다.

- 어떠한 프로세스도 (n - 1)q time unit 이상을 기다리지 않아 한번의 CPU 사용을 하게된다.

RR에서도 극단적인 상황이 있을 수 있다.

할당시간을 아주 크게 잡은 경우 FCFS스케쥴링과 같이 된다. `q large`

반대로 할당 시간을 아주 작게 잡을 경웅 Context switch 오버헤드가 커진다. `q small`

그러므로 적당한 할당 시간을 주는 것이 바람직한 방법이다.

- 장점 - 일반적으로 SJF보다 Average turnaround time이 길지만 Responese time은 더 짧다.

### 특이한 경우

동일한 작업 시간을 가진 프로세스가 다수 있을 경우 모두가 조금 조금씩의 서비스를 나누어 가며 실행하고

거의 비슷한 시간에 작업이 끝나기 때문에 효율적이지 못하다.

하지만 대부분의 경우 프로세스는 각각 다른 작업 시간을 가지고 있기에 이런 경우는 자주 없다.
