# 클로저, 고차함수

## 클로저란

- 중괄호'{ }'로 구분된 코드의 블럭아다.
- 일급 객체(일급 시민)의 역할
  - 일급 객체는 전달 인자로 보낼 수 있다.
  - 변수 또는 상수로 저장하거나 전달할 수 있다.
  - 함수의 반환 값이 될 수 있다.
- 참조 타입이다.
- 함수는 이름있는 `클로저`이다.

### 클로저 사용

- 매개변수, 반환 타입 생략가능
- return 키워드 생략 가능
- 축양된 전달인자 이름을 사용 가능
- 후행 클로저

### 클로저 기본 형태

```swift
{ (parameters) -> 반환타입 in
    statements
}
```

in은 매개변수, 반환 타입과 실행할 코드 사이가 여기서 분리된다는 단순한 뜻.

단 매개변수, 반환 타입을 안쓰면 in도 생략.

**일반적인 함수 사용**

```swift
let names = ["Eminem", "IU", "Jamking", "Tam", "Henry"]

func backward(_ s1: String, _ s2: String) -> Bool {
    return s1 > s2
}
var reversedNames = names.sorted(by: backward)
print(reversedNames)
// ["Tam","Jamking", "IU"", "Henry", "Eminem"]
```

**클로저 사용**

```swift
// 후행 클로저의 사용
var reversedNames = names.sorted() { (_ s1: String, _ s2: String) -> Bool in
    return s1 > s2
}

// sorted(by:)메서드의 소괄호까지 생략
var reversedNames = names.sorted { (_ s1: String, _ s2: String) -> Bool in
    return s1 > s2
}

// 매개변수 타입과 반환 타입 생략
var reversedNames = names.sorted { (_ s1, _ s2) in
    return s1 > s2
}

// 단축 인자 이름 사용
var reversedNames = names.sorted {
    retrunt $0 > $1
}

// 암시적 반환 표현의 사용
var reversedNames = names.sorted { $0 > $1 }
```

`클로저의 사용은 간결하다는 장점이 있지만 너무 축약하여 사용하면 오히려 가독성이 떨어질 수 있다.`

---

## 고차함수란

- 하나 이상의 함수를 인자로 취하는 함수
- 함수를 결과로 반환하는 함수

### map(변형) - 데이터를 변형하고자 할 때 사용.

기존 데이터를 변형하여 새로운 컨테이너를 만드는데, 기존 데이터는 변형되지 않는다.

**map의 장점**

- 코드의 간결성
- 재사용 용이
- 컴파일러 최적화 성능이 좋음

```swift
// map의 기본 형태
// T 타입의 transform을 받아 새로운 T타입의 컨테이너를 생성
array.map(transform: T throws -> T)
```

**for문과 map의 비교**

```swift
let numArray = [1, 3, 5, 7, 9]
var multiArray = [Int]()

for num in numArray {
    multiArray.append(num * 2)
}
print(multiArray) // [2, 6, 10, 14, 18]

// map을 사용하여 같은 기능 구현
let numArray1 = [1, 3, 5, 7, 9]
var multiArray1 = numArray1.map( { (number: Int) -> Int in
    return number * 2
})

// 클로저 축약
let numArray2 = [1, 3, 5, 7, 9]
var multiArray2 = numArray1.map { $0 * 2}
```

---

### filter(추출) - 데이터를 추출하고자 할 때 사용

기존 컨테이너에서 내부의 값을 조건에 맞는 걸로 새로운 컨테이너를 만듬

```swift
// filter의 기본 형태
// T타입의 isIncluded를 받아 새로운 T형태의 컨테이너를 생성
array.filter(isIncluded: T throws -> T)
```

**for문과 filter 비교**

```swift
// 문자열 배열 중 세글자만 추출
let stringArray = ["사과", "바나나", "청포도", "딸기", "배", "토마토"]
var threeCountArray = [String]()
for st in stringArray {
    if st.count == 3 {
        thrreCountArray.append(st)
    }
}
print(thrreCountArray) // ["바나나", "청포도", "토마토"]

// filter를 사용하여 같은 기능 구현
let stringArray1 = ["사과", "바나나", "청포도", "딸기", "배", "토마토"]
let threeCountArray1 = stringArray1.filter( { (value: String) -> Bool in
    return value.count == 3
})

// 클로저 축약
let stringArray2 = ["사과", "바나나", "청포도", "딸기", "배", "토마토"]
let threeCountArray2 = stringArray2.filter { $0.count == 3 }
```

---

### reduce(결합) - 데이터를 합쳐주기 위해 사용

기존 컨테이너에서 내부의 값들을 결합하여 새로운 값을 만듬.

**for문과 reduce 비교**

```swift
// 배열의 합
let numberArray = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
var sum = 0
for number in numberArray {
    sum += number
}
print(sum) // 55

// reduce를 사용하여 같은 기능 구현
let numberArray1 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
let sum2 = numberArray1.reduce(0, { (first: Int, second: Int) -> Int in
    return first + second
})

// 클로저 축약
let numberArray1 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
let sum1 = numberArray1.reduce(0) { $0 + $1 }
print(sum1)
```

---

### compactMap

map과 사용방법이 비슷하다.

컨테이너로 쌓어져있으면 컨테이너 안의 값으로 작업을 수행하여 다시 포장 후 반환

flatMap은 체인 형식으로 사용 가능하지만 map은 사용 불가

ex. `optionals.compactMap { $0 }.compactMap { $0 }`

```swift
let optional: [Int?] = [0, 1, 2, nil, 4, nil, 6]
let `map` = optionals.map { $0 } // [Optional(0), Optional(1), Optional(2), nil, Optional(4), nil, Optional(6)]
let `flatMap` = optonals.compactMap { $0 } // [0, 1, 2, 4, 6]
```

---

### flatMap

2차원 배열을 1차원 배열로 만들고 싶을 때 사용.

flat <- 평평하게 이런 뜻??

- 1차 배열 : [1, 2, 3, 4, 5, 6]
- 2차 배열 : [[1], [2, 3, 4], [5], [6]]

```swift
let fruit: [[String]] = [["사과", "딸기", "참외"], ["수박"], ["블루베리", "바나나"]]
let fruitNames: [String] = fruit.flatMap { $0 }
print(fruitNames) // ["사과", "딸기", "참외", "수박", "블루베리", "바나나"]
```
