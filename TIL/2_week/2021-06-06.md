# 학습 내용

## 객체지향의 사실과 오해 6장

이 장의 시작은 지도를 예로들어 설명을 이어나간다.

A에서 Z까지 가야할 때의 인간이 취할수 있는 행동이 두 가지가 있다고 예를 들어보자.

첫 번째 방법은 주변 사람에게 Z까지 가는 방법을 물어보는 것이다.

하지만 중간에 가는길에 목이말라 F에 있는 편의점에 들려 물을 마셔야하거나

목적지가 바뀌어 G로 가야하는데 다른 방향이라 다시 주변 사람에게 물어봐야하기에 첫 번째 방법은 재사용성이 떨어진다.

반면 지도를 보면서 이동하게 되면 중간에 어떤 변화가 있더라도 지도에 표시된 지형 또는 랜드마크를 따라가면 된다.

지도는 실세계 지형을 기반으로 한 추상 모델이다.

현재의 목적뿐만이 아니라 다양한 목적을 위해 재사용 될 수 있다. (범용적이다.)

지도가 범용적인 이유는 지도를 사용하려는 사람들이 원하는 '기능'에 비해 지도에 표시된 '구조'가 더 안정적이기 때문이다.

또 와닿았던 내용은 지형은 거의 변하지 않기에 과거의 지도가 현재에도 여전히 유용하게 사용될 수 있다는 것이였다.

랜드마크나 아주 조금의 최신성은 떨어지지만 적어도 지도의 수명은 특정한 경로를 찾으려는 사람들의 기능적 요구사항보다는 더 길다는 것이다.

이처럼 사람들의 요구사항은 계속 변하기에 모델이 제공해야 하는 기능 역시 이에 따라 지속적으로 변할 수 밖에 없다.

그래서 기능을 중심으로 구조를 짜게 되면 범용적이지 않고 재사용이 불가능하며 변경에 취약한 모델을 낳게 된다고 한다.

그와 반대로 구조 중심의 모델은 범용적이고 재사용이 가능하며 변경에 유연하게 대처할 수 있다.

- 범용적
- 재사용성
- 변경에 안정적

즉, 객체지향은 자주 변경되는 기능이 아닌 안정적인 구조를 기반으로 시스템을 구조화한다.

자주 변경되는 기능이 아니라 안정적인 구조를 따라 역할, 책임, 협력을 구상하라!! 이것이 이번 장의 핵심 내용이다.

---

### 기능 설계 vs 구조 설계

모든 소프트웨어 제품의 설계는 기능(Function)측면의 설계와 구조(Structure)측면의 설계가 존재한다.

- 기능 - 제품이 사용자를 위해 무엇을 할 수 있는지에 초점을 맞춘다.

- 구조 - 제품의 형태가 어떠해야 하는지에 초점을 맞춘다.

소프트웨어가 사용자에게 가치 있는 이유는 사용자가 필요로 하는 기능을 제공하기 때문이다.

훌륭한 기능이 휼륭한 소프트웨어를 만드는 충본조건이라면 훌륭한 구조는 훌륭한 소프트웨어를 만들기 위한 필요조건이다.

잘나가는 소프트웨어들이 지닌 공통적인 특징은 훌륭한 기능을 제공하는 동시에 사용자가 원하는 새로운 기능을 빠르고 안정적으로

추가할 수 있다는 것이다. 사용자가 내부 구조를 볼수 없지만 사용자의 변하는 요구사항을 반형할 수 있도록

쉽게 확장 가능한 소프트웨어를 창조할 수 있는 기반이 된다.

사용자의 요구사항은 언제든 변경되기에 설계또한 언제든 변경할 수 있는 준비를 해야하는 것은 개발자의 숙명이다.

미래의 요구사항을 미리 알고 대처할 수 없다면 대처하기 쉽도록 설계를 하는 것으로 준비를 해야한다.

객체지향은 객체의 구조에 집중하고 기능이 객체의 구조를 따르게 만든다.

시스템 기능은 더 작은 책임으로 분할되고 적절한 객체에게 분배되기에 기능이 변경되더라도 객체 간의 구조는 그대로 유지된다.

그러므로 객체지향적인 프로그래밍은 재사용성이 가능하고 변경을 수용할 수 있는 유연한 소프트웨어을 만들수 있는 기반을 제공한다.

기능과 구조를 표현하기 위해 일관되게 적용할 수 있는 두 가지 기법이 있다.

- 구조는 사용자나 이해관계자들이 도메인에 관해 생각하는 개념과 개념들 간의 관계로 표현한다.
- 기능은 사용자의 목표를 만족시키기 위해 책임을 수행하는 시스템의 행위로 표현한다.

기능을 쉽게 수직하고 표현하기 위한 기법을 `유스케이스 모델링`이라고 하고,

구조를 수집하고 표현하기 위한 기법을 `도메인 모델링`이라고 한다.

### 도메인 모델

[공부자료](http://contents.kocw.or.kr/KOCW/document/2014/Seowon/SongHaesang/05.pdf)

모든 소프트웨어는 사용자의 필요성을 충족시키기 위해 존재한다.

- 병원에서 모든 환자의 진료 기록을 보관하고 분석하기 위해 사용
- 은행에서 고객의 소중한 자산을 보호하고 관리하기 위해 사용
- 무료한 시간을 달래기 위해 게임 소프트웨어에 열중
- 등등 사람들이 관심있는 여러 특정 분야에 대한 소프트웨어

이처럼 사용자가 프로그램을 사용하는 대상 분야를 `도메인`이라고 한다.

도메인 모델에서 모델은 대상을 단순화해서 표현한 것이다. 즉, 대상을 추상화하고 단순화한 것이다.

`모델은 지식을 선택적으로 단순화하고 의식적으로 구조화한 형태이다.` - Evans

도메인 모델이란 사용자가 프로그램을 사용하는 대상 영역에 관한 지식을 선택적으로 단순화하고

의식적으로 구조화한 형태를 말한다.

도메인 모델은 단순히 다이어그램이 아닌 이해관계자들이 바라보는 `멘탈 모델`이다.

(도메인 모델은 도메인에 대한 사용자 모델, 디자인 모델, 시스템 이미지를 포괄하도록 추상화한 소프트웨어 모델)

멘탈 모델은 사람들이 자기 자신, 다른 사람, 환경, 자신이 상요작용하는 사물들에 대해 갖는 모든 모형이다.

소프트웨어 사용자들도 마찬가지로 도메인에 존재하는 현상을 이해하고 현상에 반응하기 위해 도미인과 관련된 멘탈 모델을 형성한다.

`디자인 모델(디자인 모델) -> 시스템(시스템 이미지) <-> 사용자(사용자 모델)`

---

객체지향을 사용하면 사용자들이 이해하고 있는 도메인의 구조와 최대한 유사하게 코드를 구조화할 수 있다.

객체지향 패러다임은 사용자의 관점, 설계자의 관점, 코드의 모습을 모두 유사한 형태로 유지할 수 있게 하는

유용한 사고 도구와 프로그래밍 기법을 제공한다. 이러한 특징을 `연결완전성` 또는 `표현적 차이`라고 한다.

**표현적 차이**

소프트웨어 객체는 현실 객체를 모방한 것이 아닌 은유를 기반으로 재창조한 것이다.

그러므로 현실 객체가 갖지 못한 특성을 가질 수도 하지 못하는 행동을 할 수도 있다.

❓ 은유를 통해 투영해야 하는 대상은?? 사용자가 도메인에 대해 생각하는 개념들

소프트웨어 객체는 그 대상이 현실적인지 그렇지 않은지에 상관없이 도메인 모델을 통해

표현되는 도메인 객체들을 은유해야 한다. 이것이 도메인 모델이 중요한 이유다.

```swift
// 구현 - 도메인의 개념과 관계를 은유해서 코드로 작성

Account {
    accountNumber
    amount

    calculateInterest(when:)
}

Interest {
    amount
    paymentDate
}

// 도메인 모델 - 도메인 모델의 개념들은 코드에서 사용할 개념과 관계를 제공
계좌 {
    계좌번호
    예금액
}

이자 {
    금액
    지급일자
}
```

도메인 모델을 기반으로 소프트웨어의 구조를 설계하면 변경에 유연하게 대응할 수 있는 탄력적인 소프트웨어를 만들 수 있다.

도메인 모델은 기능을 구현할 때 참조할 수 있는 궁극적인 지도다.

---

### 유스케이스

사용자의 목 표를 달성하기 위해 사용자와 시스템 간에 이뤄지는 상호작용의 흐름을

텍스트로 정리한 것을 `유스케이스`라고 한다.

유스케이스의 가치는 사용자들의 목표를 중심으로 시스템의 기능적인 요구사항들을 이야기하는 형식으로 묶을 수 있다는 점이다.

산발적으로 흩어져 있는 기능에 사용자 목표라는 문맥을 제공함으로 각 기능이 유기적인 관계를 지닌 체계를 이룰 수 있게 한다.

**유스케이스 특성**

1. 유스케이스는 사용자와 시스템 간의 상호작용을 보여주는 '텍스트'다.

   다이어그램에 노력을 쏟지마라. 중요한 것은 그 안에 담겨진 이야기이다.

2. 유스케이스는 하나의 시나리오가 아니라 여러 시나리오들의 집합이다.

3. 유스케이스는 단순한 피처 목록과 다르다.

4. 유스케이스는 사용자 인터페이스와 관련된 세부 정보를 포함하지 말아야 한다.

5. 유스케이스는 내부 설계와 관련된 정보를 포함하지 않는다.

---

## 독서 스터디 얘기 나누기

1. 상속관계에서의 책임 혁력 관계는 어떻게 될까?

   자식 클래스가 부모클래스 것을 가져다 쓸게!! 내가 너가 될게와 같은 의미로 얘기를 나눔

2. TDD를 할 때에 Private는 어떻게 해야할까?

   Private 인터페이스들은 공용인터페이스가 구현되기 위한 재료들이다.

   그러므로 공용인터페이스가 Test에 성공했다면 내부 인터페이스들은 자연스레 안전한 코드가 될 것이다.

3. 인터페이스는 캡슐화와 동일한 의미일까?

   맞다는 결론이 나왔다. 인터페이스들 하나하나가 캡슐화를 통해 구현이 이루어지며

   그것을 내부와 외부로 결정짓는 것은 은닉화라고 할 수 있다.

   ```
   캡슐화의 특성

   1. 추상화 단위가 된다.
       - 캡슐화가 된다는 것은? 곧 추상화가 된다는 것!
   2. 재사용의 단위가 된다.
       - 객체 지향에서 캡슐화의 단위는 클래스 단위(또는 다른)로 정의하고, 클래스를 통해 객체 단위로 생성되어 움직임
   3. 정보은닉을 실현한다.
       - 캡슐화를 통해 인터페이스를 제외한 데이터와 함수들을 캡슐 속으로 숨기기 때문에 정보인닉이 실현됨.
   ```
