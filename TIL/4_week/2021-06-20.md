# 학습 내용

## 객지체향과 사실과 오해 7장

### 객체지향 설계 안에 존재하는 세 가지 상호 연관된 관점 (마틴 파울러)

- 개념 관점(Conceptual Perspective) - 클래스가 은유하는 개념

  설계는 도메인 안에 존재하는 개념과 개념들의 관계를 표현한다.

  - 도메인이란?? 사용자들이 관심을 가지고 있는 특정 분야나 주제.

  소프트웨어는 도메인에 존재하는 문제를 해결하기 위해 개발된다.

  개념 관점은 사용자가 도메인을 바라보는 관점을 반영하며, 실제 도메인의 규칙과 제약을 최대한 유사하게 반영하는 것이 핵심이다.

- 명세 관점(Specification Perspective) - 클래스의 공용 인터페이스

  소프트웨어 안에서 살아 숨쉬는 객체들의 책임에 초점을 맞춘다. (객체의 인터페이스)

  이 관점에서 개발자는 객체가 협력을 위해 `무엇`을 할 수 있는가에 초점을 맞춘다.

  객체지향 설계를 낳는 가장 기본적인 원칙은 인터페이스와 구현을 분리하는 것이다!

  `구현이 아닌 인터페이스에 대해 프로그래밍하라` - GOF

- 구현 관점(Implementation Perspective) - 클래스의 속성과 메서드

  개발자에게 가장 익숙한 관점으로, 실제 작업을 수행하는 코드와 연관돼 있다.

  이 관점의 초점은 객체들이 `책임`을 수행하는 데 필요한 동작하는 코드를 작성하는 것이다.

  객체에 책임을 `어떻게` 수행할지를 생각하며 인터페이스를 구현하는 데 필요한 속성과 메서드를 클래스에 추가한다.

역할, 책임, 협력을 이용해 객체의 인터페이스를 식별한다.

객체가 협력에 참여하기 위해 수신해야 할 메시지를 결정하고 메시지들이 모여 객체의 인터페이스를 구성한다.

따라서 협력 안에서 메시지를 선택하고 메시지를 수신할 객체를 선택하는 것은 인터페이스이며, 즉 명세 관점에서 객체를 바라보는 것이다.

---

### 쥬스가게를 통해 알아보는 관점

길거리에서 종종 보이는 도메인으로 하나의 쥬스가게가 있다.

쥬스가게에서는 딸기쥬스, 오렌지쥬스, 망고쥬스, 키위쥬스 네 가지 쥬스를 판매한다.

가게 내부에는 과일을 가는 믹서기 소리와 상큼한 과일들의 향이나며 몇 안되는 테이블들이 있고,

그 위에 쥬스의 이름과 가격이 적힌 메뉴판이 비치돼어있다.

손님은 가게에 들어와 메뉴판을 훑어본 후 쥬스를 주문한다.

주문을 받은 쥬스를 제조하는 것은 점원의 몫이다.

쥬스가게는 하나의 도메인이며, 최종 목표는 손님이 쥬스를 주문하는 것을 객체를 이용해 표현하는 것이다.

- 메뉴판 (딸기쥬스, 오렌지쥬스, 망고쥬스, 키위쥬스 또한 메뉴 항목들 객체)
- 손님 -> 메뉴판에서 쥬스를 선택할 수 있다. & 손님은 점원에게 쥬스를 주문한다.
- 점원 -> 쥬스를 제조한다.
- 제조된 쥬스(딸기쥬스 객체, 오렌지쥬스 객체, 망고쥬스 객체, 키위쥬스 객체)

손님은 메뉴판에서 주문할 쥬스를 선택할 수 있어야한다.

따라서 손님은 어떤 식으로든 메뉴판을 알아야하며, 손님과 메뉴판 두 객체 사이에 관계가 존재한다는 것을 암시한다.

손님은 점원에게 주문을 해야하므로 이 둘 사이에도 관계가 존재한다.

점원은 쥬스를 제조하는 사람이므로 자신이 만든 쥬스와 관게를 맺는다.

`동적인 객체를 정적인 타입으로 추상화해서 복잡성을 낮춰라` 타입은 분류를 위해 사용된다.

상태와 무관하게 동일하게 행동할 수 있는 객체들은 동일한 타입으로 뷴류할 수 있다.

- 손님 - 손님 타입 인스턴스
- 점원 - 점원 타입 인스턴스
- 메뉴판 - 메뉴판 타입 인스턴스
- 딸기쥬스, 오렌지쥬스, 망고쥬스, 키위쥬스 - 메뉴 항목 타입 인스턴스

하나의 메뉴판 객체는 다수의 메뉴 항목 객체로 구성되어 있다.

메뉴판 객체와 메뉴 항목 객체는 따로 떨어져 있지 않고 하나의 단위로 움직인다.

이 관점에서는 메뉴 항목 객체가 메뉴판 객체에 포함되어 있다고 할 수 있는데 이를 메뉴판 타입과 메뉴 항목 타입간의

`합성 관계`로 단순화 하면 더 보기가 쉬워진다.

<img width="972" alt="스크린샷 2021-06-20 오전 12 54 23" src="https://user-images.githubusercontent.com/70311145/122648080-5c45a380-d162-11eb-95a3-485cc7613e18.png">

메뉴판 타입에서 메뉴 항목 타입쪽으로 향하는 선에 그려진 속이 찬 마름모는 `포함 관계` 또는 `합성 관계`를 나타낸다.

숫자 4는 메뉴판에 포함될 메뉴 항목이 4개라는 것을 의미한다.

<img width="574" alt="스크린샷 2021-06-20 오전 1 02 46" src="https://user-images.githubusercontent.com/70311145/122648244-47b5db00-d163-11eb-9999-665d92eb5ef3.png">

손님 타입은 메뉴판 타입을 알고 있어야 원하는 음료를 선택할 수 있다.

메뉴판 타입은 손님의 일부가 아니기에 이 관계는 합성 관계가 아니다. 이런 경우 단순한 선으로 연결한다.

이와 같이 한 타입의 인스턴스가 다른 타입의 인스턴스를 포함하지 않지만 서로 알고 있어야 할 경우 `연관 관계`라고 한다.

<img width="580" alt="스크린샷 2021-06-20 오전 1 02 58" src="https://user-images.githubusercontent.com/70311145/122648245-48e70800-d163-11eb-817e-087f2b36cc05.png">

점원 타입은쥬스를 제조해야 하므로 쥬스 타입을 알고 있어야한다.

메뉴판 타입, 쥬스타입 중 어떤 것도 점원의 일부가 아니므로 포함하는 관계가 아니다.

이처럼 소프트웨어가 대상으로 하는 영역인 도메인을 단순화해서 표현한 모델을 `도메인 모델`이라고 한다.

도메인을 단순화해서 이해했다면 다음은 초첨을 소프트웨어로 옮기는 일이다.

`객체제향의 세계는 협력하는 자율적인 객체들의 공동체이다`

도메인 모델을 설계했다면 다음 단계는 협력을 설계하는 일이 될 것이다. 즉, 적절한 객체에게 적절한 책임을 할당하는 것이다.

---

### 설계와 구현

`객체지향 설계의 목표는 훌륭한 객체를 설계하는 것이 아닌 훌륭한 협력을 설계하는 것이다.`

협력을 설계할 때는 객체가 메시지를 선택하는 것이 아니라 메시지가 객체를 선택하게 해야한다.

쥬스가게에서 설계하고 있는 협력은 쥬스를 주문하는 것이며, 첫 번째 메시지는 '쥬스를 주문하라'가 된다.

<img width="212" alt="스크린샷 2021-06-21 오전 12 42 03" src="https://user-images.githubusercontent.com/70311145/122680426-09372380-d22a-11eb-9f35-f93f215b9aa4.png">

'딸기 쥬스를 주문하라' 메시지는 '쥬스를 주문하라(딸기 쥬스)'와 같이 인자를 포함하는 형식으로 구현될 것이다.

메시지를 찾았으면 이 메시지를 처리하기에 적합한 객체를 선택해야한다.

'쥬스를 주문하라'라는 메시지를 수신한ㄹ 객체는 손님이 된다.

따라서 메시지를 처리할 객체는 손님 타입의 인스턴스이다. 그 다음 손님 객체는 커피를 주문할 책임을 할당받게 된다.

<img width="325" alt="스크린샷 2021-06-21 오전 12 45 26" src="https://user-images.githubusercontent.com/70311145/122680428-0a685080-d22a-11eb-84bf-7d36b40fa59b.png">

손님이 할당된 책임을 수행하는 도중에 스스로 할 수 없는 일 이 있다면 다른 객체에게 이를 요청해야한다.

이 요청은 손님 객체에서 외부로 전송되는 메시지를 정의한다.

메뉴 항목은 고객의 일부가 아니라 메뉴판의 일부이다. 따라서 고객은 자신이 선택한 메뉴 항목을 누군가가 제공해 줄 것을 요청한다.

<img width="464" alt="스크린샷 2021-06-21 오전 12 49 25" src="https://user-images.githubusercontent.com/70311145/122680600-f3762e00-d22a-11eb-9244-b0041fca4743.png">

이렇게 '메뉴 이름'이라는 인자를 포함해 함께 전송한다.

'메뉴 항목'은 이 메시지를 수신한 객체가 손님에게 무엇을 응답해야 하는지를 나타낸다.

'메뉴 항목을 찾아라'라는 메시지를 수신한 객체는 '메뉴 이름'에 대응되는 '메뉴 항목을'반환해야 한다.

<img width="579" alt="스크린샷 2021-06-21 오전 12 49 39" src="https://user-images.githubusercontent.com/70311145/122680599-f2dd9780-d22a-11eb-89c4-4df7775dbaa4.png">

메뉴 항목을 가장 잘 알고 있는 객체인 메뉴판 객체에게 이 책임을 처리할 수 있다.

`객체지향 세계에서는 모든 객체가 능동적이고 자율적인 존재이다. 따라서 설계자는 무생물을 생물처럼 '의인화'해야 한다`

<img width="618" alt="스크린샷 2021-06-21 오전 12 51 29" src="https://user-images.githubusercontent.com/70311145/122680597-f2450100-d22a-11eb-9e67-1e9423b412b1.png">

손님은 자신이 주문한 쥬스를 메뉴 항목에 얻었으므로 이제 메뉴 항목에 맞는 쥬스를 제조해달라고 요청할 수 있다.

손님은 쥬스를 제조하는 메시지의 인자로 메뉴 항목을 전달하고 반환값으로 제조된 쥬스를 받게된다.

<img width="565" alt="스크린샷 2021-06-21 오전 12 51 42" src="https://user-images.githubusercontent.com/70311145/122680596-f1ac6a80-d22a-11eb-90a0-2af79829c61d.png">

쥬스를 제조하는 것은 당연히 점원이 되게 된다.

점원은 쥬스를 제조하는 데 필요한 모든 정보를 알고 있다.

예를들어 바나나 쥬스를 만들기 위한 지식은 점원의 상태, 기술은 점원의 행동으로 간주할 수 있다.

이 관점에서 점원은 스스로의 판단과 지식에 따라 행동하는 자율적인 존재다.

<img width="574" alt="스크린샷 2021-06-21 오전 12 52 15" src="https://user-images.githubusercontent.com/70311145/122680595-f07b3d80-d22a-11eb-87b1-20923744a80e.png">

협력에 필요한 객체의 종류와 책임, 주고받아야 하는 메시지에 대한 윤곽이 잡혔으면

메시지를 정제함으로써 각 객체의 인터페이스를 구현 가능할 정도로 상세하게 정제하는 것이다.

### 스터디에서 Swift로 짜본 코드

```swift
struct Customer {
    func order(name: String, menuList: MenuList, clerk: Clerk) -> Juice {
        let orderJuice = menuList.selectMenu(name: "딸기 쥬스")
        return clerk.makeJuice(order: orderJuice)
    }
}

struct MenuList {
    enum JuiceList {
        case Strawberry
        case Banana
        case Kiwi
        case water
    }

    func selectMenu(name: String) -> JuiceList {
        switch name {
        case "딸기 쥬스":
            return .strawberry
        case "바나나 쥬스":
            return .banana
        case "키위 쥬스":
            return .kiwi
        default:
            return .water
        }
    }
}

struct Clerk {
    func makeJuice(order: menuList.JuiceList) -> Juice {
        return Juice(juiceList: order)
    }
}

struct Juice {
    var juiceList: MenuList.JuiceList
}

let menuList = MenuList()
let clerk = Clerk()
let customer = Customer()

let juice = customer.order(name: "딸기 쥬스", menuList: menuList, clerk: clerk)
print(juice)
```

### 정리

1. 개념 관점, 명세 관점, 구현 관점은 동일한 코드를 바라보는 서로 다른 관점이다.

   훌륭한 객체지향 개발자는 하나의 클래스 안에 세 가지 관점을 모두 포함하면서도

   각 관점에 대응되는 요소를 명확하고 깔끔하게 드러낼 수 있다.

2. 도메인 개념을 참조하는 이유는 도메인 개념 안에서 적절한 객체를 선택하는 것은 도메인에 대한

   지식을 기반으로 코드의 구조와 의미를 쉽게 유추할 수 있게 한다.

   소프트웨어는 항상 변하며 설계는 변경을 위해 존재한다.

   소프트웨어 클래스가 도메인 개념을 따르면 변화에 쉽게 대응할 수 있다.(유지보수)

3. 인터페이스와 구현을 분리하라.

   인터페이스가 구현 세부 사항을 노출하기 시작하면 아주 작은 변동에도 전체 협력이

   요동치는 취약한 설계를 얻을 수밖에 없다.

   명세 관점이 설계를 주도하게 하면 설계의 품질이 향상될 수 있다.

   캡슐화를 위반해서 구현을 인터페이스 밖으로 노출해서도 안 되고, 인터페이스와 구현을 명확하게 분리하지 않고

   흐릿하게 섞어놓는 것 또한 안된다.
