# 운영체제 스터디 5회차 (Process Management)

## 동기식 입출력과 비동기식 입출력의 차이점 되돌아보기

두 경우 모드 I/O의 완료는 인터럽트로 알려준다.

<img width="699" alt="스크린샷 2021-07-03 오후 3 22 26" src="https://user-images.githubusercontent.com/70311145/124346409-9c545e00-dc19-11eb-87e0-66ce9dd136dd.png">

### 동기식 입출력

I/O 요청 후 입출력 작업이 완료된 후에야 제어가 사용자 프로그램에 넘어감

프로세스가 입출력 진행되는 동안 끝날때까지 아무일도 하지 않고 기다린다.

입출력이 끝나는 것을 보고나서야 인스트럭션을 실행한다.

### 비동기식 입출력

I/O가 시작된 후 입출력 작업이 끝나기를 기다리지 않고 제어가 사용자 프로그램에 즉시 넘어감

입출력이 진행되는 동안에 그 프로세스가 곧바로 CPU를 잡아서 인스트럭션을 실행한다.

---

## 스레드 (Thread)

<img width="223" alt="스크린샷 2021-07-03 오후 3 30 57" src="https://user-images.githubusercontent.com/70311145/124346412-9fe7e500-dc19-11eb-8b07-f3a3d89cff41.png">

코드, 데이터, 스택으로 구성된 프로세스를 하나만 띄어놓고, 현재 CPU가 코드의 어느 부분을 실행하고 있는지

Program Counter만 여러개를 두는 것이다.

<img width="460" alt="스크린샷 2021-07-03 오후 3 33 42" src="https://user-images.githubusercontent.com/70311145/124346413-a0807b80-dc19-11eb-88c1-be963da90d58.png">

즉, 프로세스 하나에 CPU수행단위만 여러개 두고 있는것을 스레드라고 한다.

- 프로세스 내부에 CPU수행 단위가 여러개 있는 경우를 스레드라고 부른다.

스레드 하나가 코드를 실행하다가 함수 호출을 하면 그 함수를 호출하고 리턴하는 과정을

Stack에 쌓아둬야 하지만 CPU 수행단위가 여러개 있게되면 Stack도 별도로 둬야한다.

프로세스 하나에서 공유할 수 있는 것은 최대한 공유하고(메모리 주소공간), 상태 또한 공유한다.

다만 별도로 가지고 있는 것은 CPU 수행과 관련된 PC또는 register, Stack 같은 것들이다.

Thread의 구성은

- Program counter, register set, stack space

Thread가 다른 Thread와 공유하는 작업(task)

- code section, data section, OS resources

### 스레드의 장점

- 하나의 프로세스 안에 스레드를 여러개 두게 되면 하나의 스레드가 blocked(waiting) 상태일때도

  동일한 작업 내의 다른 스레드가 실행(running)되어 빠르게 처리가 가능하다.

  ex) 브라우저르 띄울때 HTML의 텍스트가 먼저 보이고, 이미지가 곧 바로 뒤어 생성될때 (비동기식)

- 자원 공유 (Code, Data, Resource)

- 동일한 일을 수행하는 다중 스레드가 협력하여 높은 처리율과 성능 향상을 얻을 수 있다.

- 스레드를 사용하면 `병렬성`을 높일 수 있다.

  ex) 롤 켜놓고 op.gg 볼때 ㅎㅎ

- 빠른 응답성, 자원 절약

> 문맥 교환, 프로세스 생성은 오버헤드가 크지만 스레드간의 CPU 스위치 또는 프로스세스 내의 스레드 생성은 오버헤드가 적다.

### 스레드 구현 방법

- 운영체제 커널의지원을 받는다. (Kernel Threads)

  스레드가 여러 개 있다는 것을 운영체제 커널이 알고있다.

- 라이브러리 형태로 구현한다. (User Threads)

  스레드가 여러 개 있다는 것을 운영체제 커널이 모른다.

- Real-time Threads

---

## Process Management

하나의 부모 프로세스가 (여러)자식 프로세스를 생성(복제)한다.

- 트리 계층 구조를 가진다.

프로세스는 운영체제로 부터 자원을 받으며 부모와 공유를 할 수 있다.

하지만 부모 자식간의 프로세스들도 CPU를 얻기 위해 경쟁하는 관계이다.

그러므로 부모와 공유하기 보다는 공유하지 않는 모델이 일반적이다.

### 수행(Execution)

- 부모와 자식은 공존하며 수행되는 모델
- 자식이 종료(terminate)될 때까지 부모가 기다리는 (wait)모델

### 프로세스 생성

- 주소 공간

  - 자식은 부모의 주소 공간을 복사한다. (또는 운영체제의 데이터들)
  - 자식은 그 공간에 새로운 프로그램을 올림

- fork() 시스템 콜이 새로운 프로세스를 생성

  - 부모를 그대로 복사
  - 주소 공간 할당

- fork 다음에 이어지는 exec() 시스템 콜을 통해 새로운 프로그램을 메모리에 올림

> 부모가 자식 프로세스를 바로 생성하는 것이아니라 운영체제를 통해 운영체제가 대신 자식 프로세스를 생성한다.

### 프로세스 종료

- 프로세스가 마지막 명령을 수행한 후 운영체제에게 이를 알려준다 (exit)

  - 자식이 부모에게 출력 데이터를 보냄 (via `wait`)
  - 프로세스의 각종 자원들이 운영체제에게 반납됨

- 부모 프로세스가 자식의 수행을 종료시킴(`abort`)
  - 자식이 할당 자원의 한계치를 넘어섬
  - 자식에게 할당된 작업이 더 이상 필요하지 않음
  - 부모가 종료 하는경우

사람과 다르게 컴퓨터는 자식이 죽고 부모가 죽어야한다. 잔인해,,,,
