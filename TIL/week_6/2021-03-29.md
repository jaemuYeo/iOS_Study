# Swift Collection 학습

1. 클래스로 구현되어 있는 컬렉션 Foundation Collection -> 참조형식

   ex) NSArray, NSDictionary, NSSet

2. 구조체로 구현되어 있는 컬렉션 Swift Collection -> 값형식

   ex) Array, Dictionary, Set

## Array

```swift
// 정식 문법
let intArray: Array<Int>
// 단축 문법
let intArray2: [Int]

// 빈 배열 (초기화)
let emptyArray: [Int] = []
// 정식문법
let emptyArray2: Array<Int>()
// 단축문법
let emptyArray3: [Int]()

// 반복되는 단일 값의 지정된 수를 포함하는 새 배열만들기
init(repeating:count:)

let zeroArray = [Int](repeating: 0, count: 10)
print(zeroArray) // [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]

// 배열의 요소 수
count
let nums = [1, 2, 3, 4, 5]
nums.count // 3
nums.count == 0 // false

// 값이 비어있는지 확인
isEmpty
nums.isEmpty // false
emptyArray.isEmpty // true

// 배열의 인덱스 접근
let name = ["Jamking", "Henry", "Babo"]
name[0] // "Jamking"
name[2] // "Babo"
name[0...1] // ["Jamking", "Henry"]
name[name.startIndex] // "Jamking"
name[name.index(before: name.endIndex)] // "Babo"
name.first // "Jamking"
name.last // "Babo"
// nil도 반환하므로 옵셔널임을 알 수 있음
emptyArray.first // nil
emptyArray.last // nil
```

### 배열 편집 방법

배열의 값이 변할 수 있기에(가변성) var 사용

```swift
var alphabet = ["A", "B", "C"]
// .append -> 배열의 마지막에 추가(하나의 요소 추가)
alphabet.append("E") // ["A", "B", "C", "E"]
// .append(contensOf:) -> 두개이상의 요소 추가
alphabet.append(contentsOf: ["F", "G"]) // ["A", "B", "C", "E", "F", "G"]

// .insert -> 원하는 위치에 요소 추가
alphabet.insert("D", at: 3) // ["A", "B", "C", "E", "E", "F", "G"]
alphabet.insert(contentsOf: ["a", "b", "c"], at: 0)
// ["a", "b", "c", "A", "B", "C", "E", "E", "F", "G"]

// 해당 인덱스 값 변경
alphabet[0...2] = ["x", "y", "z"] // ["x", "y", "z"]
apphabet
// ["x", "y", "z", "A", "B", "C", "E", "E", "F", "G"]

// 지정된 요소의 하위 범위를 지정된 컬렉션으로 변경
alphabet.replaceSubrange(0...2, with: ["a", "b", "c"])
// ["a", "b", "c", "A", "B", "C", "E", "E", "F", "G"]

alphabet[0...2] = ["z"] // ["z"]
alphabet // ["z", "A", "B", "C", "E", "E", "F", "G"]

// 원하는 요소 삭제
alphabet[0..<1] = []
alphabet // ["A", "B", "C", "E", "E", "F", "G"]
```

### 배열 삭제

```swift
alphabet = ["A", "B", "C", "D", "E", "F", "G"]
alphabet.remove(at: 2) // "C"
alphabet // ["A", "B", "D", "E", "F", "G"]

// 첫 번째 배열 삭제 .removeFirst
alphabet.removeFirst // "A"
alphabet // ["B", "D", "E", "F", "G"]

// 원하는 인덱스만큼 첫 번째 인덱스 부터 삭제
alphabet.removeFirst(2) // ["E", "F", "G"]

// 마지막 인덱스 삭제
alphabet.removeLast() "G"
alphabet // ["E", "F"]

// 모든 배열 삭제 .removeAll()
alphabet.removeAll() // []

// 마지막 배열을 삭제, 빈 값일 경우 nil 반환 .popLast()
alphabet.popLast() // nil
alphabet = ["A", "B", "C", "D", "E", "F", "G"]
alphabet.popLast() // "G"
alphabet // ["A", "B", "C", "D", "E", "F"]

// 컬렉션에서 지정된 하위 범위의 요소를 제거
alphabet.removeSubrange(0...2) // ["D", "E", "F"]

// 인덱스 범위만큼 제거
alphabet[0...2] = []
alphabet // []
```

### 배열 비교, 확인

```swift
let a = ["A", "B", "C"]
let b = ["a", "b", "c"]
a == b // false
a != b // true

// 이 시퀀스와 다른 시퀀스가 ​​동일한 순서로 동일한 요소를 포함하는지 여부를 나타내는 부울 값을 반환
a.elementsEqual(b) // false

// 배열에 요소가 포함되어있는지 확인 후 부울 값 반환
let nums = [1, 2, 1, 5, 3, 6, 7, 4, 0]
nums.contains(1) // true
nums.contains(8) // false

// 컬렉션에서 지정된 값이 나타나는 첫 번째 인덱스를 반환
nums.firstIndex(of: 1) // 0
// 컬렉션에서 지정된 값이 나타나는 마지막 인덱스를 반환
nums.lastIndex(of: 1) // 3
```

### 배열 정렬

```swift
// 정렬된 새로운 배열을 리턴 .sorted
let nums = [1, 2, 1, 5, 3, 6, 7, 4, 0]
nums.sorted() // [0, 1, 1, 2, 3, 4, 5, 6, 7]

// 내림차순
nums.sorted { (a, b) -> Bool in return a > b }
// [7, 6, 5, 4, 3, 2, 1, 1, 0]

nums.sorted().reversed()
[Int](nums.sorted().reversed())

// 배열을 직접 정렬
var mutableNums = nums

mutableNums.sort() // [0, 1, 1, 2, 3, 4, 5, 6, 7]
mutableNums.reversed() // [7, 6, 5, 4, 3, 2, 1, 1, 0]

// 요소 순서 변경
mutableNums.swapAt(0, 1) //  [6, 7, 5, 4, 3, 2, 1, 1, 0]
// 요소 순서 랜덤 변경
mutableNums.shuffle()
```

## Dictionary

Key, Value로 정의
정렬되지 않은 컬렉션 (정렬한다고해도 의미 없음)

```swift
// 생성
var dict = ["A": "App", "B": "Bus", "C": "Car", "D": "Dev"]
// 초기화
dict = [:]

// 딕셔너리 타입
let dict1: Dictionary<String, Int> // 정식문법
let dict2: [String: Int] // 간편문법

// 딕셔너리 생성 방법 종류
let emptyDict: [String: String] = [:]
let emptyDict1: [String: String]()
let emptyDict2: DIctionary<String, String>()

// 딕셔너리 검사
let words = ["A": "App", "B": "Bus", "C": "Car", "D": "Dev"]
words.count // 4
words.isEmpty // false

// 키에 접근
words["A"] // "App"
words["App"] // nil

let a = words["E"] // nil
요소 추가
let b = words["E", default: "Empty"] // "Empty"

// 딕셔너리 키 순서대로 출력
for i in words.keys.sorted() {
    print(i)
}
/*
A
B
C
D
*/

// 딕셔너리 값 순서대로 출력
for i in words.values.sorted() {
    print(i)
}
/*
App
Bus
Car
Dev
*/

// 키와 값 배열로 만들기
let keys = Array(words.keys.sorted())
// ["A", "B", "C", "D"]
let values = Array(words.values)
// ["Dev", "Car", "Bus", "App"]
```

### 딕셔너리 요소 관리

```swift
// 배열과 마찬가지로 내부 값이 변경되므로 var 키워드로 선언
var words = [String: String]()
// 하나의 요소 저장
words["A"] = "App"
words["B"] = "Bus"
words.count // 2

// 새로운 요소 저장(교체) - 키와 값 교체(기존 값)
words["B"] = "Banana"
words["A"] = "Apple"
words // ["B": "Banana", "A", "Apple"]

// 새로운 요소 추가(메서드)
words.updateValue("City", forKey: "C") // 새로운 키 이므로 nil
words.updateValue("Circle", forKey: "C")

// 요소 삭제
words["B"] = nil // nil
words // ["A": "Apple", "C": "Circle"]
words["F"] = nil // 존재하지 않는 키를 삭제해도 에러나지 않음 nil

// 요소 삭제(메서드)
words.removeValue(forKey: "A") // 삭제된 키의 값이 리턴 "Apple"
words.removeValue(forKey: "A") // 이미 삭제된 키이므로 nil 리턴

words.removeAll() // 전체 딕셔너리 삭제
words // [:]
```

### 딕셔너리 비교방법

```swift
let a = ["A": "Apple", "B": "Banana", "C": "City"]
let b = ["A": "Apple", "C": "City", "B": "banana"]

a == b // 저장되어 있는 키와값이 동일하다면 순서 상관없음
a != b
// 대소문자는 구분

a.elementsEqual(b) { (lhs, rhs) -> Bool in
    return lhs.key.caseInsensitiveCompare(rhs.key) == .orderedSame && lhs.value.caseInsensitiveCompare(rhs.value) == .orderedSame
}
// 두 딕셔너리를 먼저 정렬
let aKeys = a.keys.sorted()
let bKeys = b.keys.sorted()

aKeys.elementsEqual(bKeys) { (lhs, rhs) -> Bool in
    guard lhs.caseInsensitiveCompare(rhs) == .orderedSame else {
        return false
    }
    guard let lv = a[lhs], let rv = b[rhs], lv.caseInsensitiveCompare(rv) == .orderedSame else {
        return false
    }
    return true
}// 정렬했기때문에 매번 같은 정렬로 실행

// 딕셔너리 검색
let words = ["A": "apple", "B": "Banana", "C": "City"]

let c: ((String, String)) -> Bool = {
    $0.0 == "B" || $0.1.contains("i")
}

words.contains(where: c)

let r = words.first(where: c) // 검색된 첫번째 요소 검색
// 리턴값이 항상 달라진다 배열은 정렬이 안되어있기 때문
r?.key
r?.value

words.filter(c)
```

## Set

요소의 유일성을 판단하고 빠른 검색을 위해 사용

중복된 값을 허용하지 않음

```swift
let set: Set<Int> = [1, 2, 2, 3, 3, 3] // {3, 2, 1}
set.count // 3
set.sorted() / [1, 2, 3]
set.isEmpty // nil
set.contains(1) // true

var words = Set<String>() // Set 선언

var insertResult = words.insert("Swift")
insertResult.inserted // true
insertResult.memberAfterInsert // "Swift"

// 이미 들어있는 요소를 넣을 경우
insertResult = words.insert("Swift")
insertResult.inserted // false
insertResult.memberAfterInsert "Swift"

var updateResult = words.update(with: "Swift")
updateResult // "Swift"

updateResult = words.update(with: "Apple")
updateResult // nil
```

### 요소 비교

```swift
var a: Set = [1, 2, 3, 4, 5, 6, 7, 8, 9]
var b: Set = [1, 3, 5, 7, 9]
var c: Set = [2, 4, 6, 8, 10]
var d: Set = [1, 7, 5, 9, 3]

a == b // false
a != b // true
// 요소의 동일성만 판단
b == d // true

b.elementsEqual(d) // false

// 부분집합
a.isSubset(of: a) // 부분집합 ture
a.isStrictSubset(of: a) // 진부분집합 false

b.isSubset(of: a) // true
b.isStrictSubset(of: a) // true

// 상위집합
a.isSuperset(of: a) // true
a.isStrictSuperset(of: a) // false

a.isSuperset(of: b) // true
a.isStrictSuperset(of: b) // true

a.isSuperset(of: c) // false
a.isStrictSuperset(of: c) // false

// 교집합
a.isDisjoint(with: b) // false
a.isDisjoint(with: c) // false
b.isDisjoint(with: c) // true

var e: Set = [1, 2, 3, 4, 5, 6, 7, 8, 9]
var f: Set = [1, 3, 5, 7, 9]
var g: Set = [2, 4, 6, 8, 10]

// 합집합의 새로운 set
var result = f.union(c) // {5, 7, 6, 3, 1, 2, 8, 10, 9, 4}
result = f.union(e) // {9, 7, 8, 1, 2, 5, 3, 6, 4}
f.formUnion(g) // {7, 10, 9, 1, 8, 3, 6, 5, 2, 4}

e = [1, 2, 3, 4, 5, 6, 7, 8, 9] // {5, 7, 6, 3, 1, 2, 8, 9, 4}
f = [1, 3, 5, 7, 9] // {1, 5, 7, 3, 9}
g = [2, 4, 6, 8, 10] // {2, 4, 6, 10, 8}

result = e.intersection(f) // {3, 7, 9, 5, 1}

result = g.intersection(f) // Set([])

e.formIntersection(f)
e // {1, 5, 9, 7, 3}

f.formIntersection(g) // Set([])

e = [1, 2, 3, 4, 5, 6, 7, 8, 9] // {7, 1, 2, 6, 8, 4, 3, 9, 5}
f = [1, 3, 5, 7, 9] // {3, 1, 5, 7, 9}
g = [2, 4, 6, 8, 10] // {10, 6, 4, 2, 8}

// 여집합
result = e.symmetricDifference(f) // {2, 6, 8, 4}
result = g.symmetricDifference(f) // {9, 10, 5, 7, 3, 6, 4, 2, 8, 1}
e.formSymmetricDifference(f) // {2, 6, 8, 4}

e = [1, 2, 3, 4, 5, 6, 7, 8, 9] // {6, 7, 8, 3, 9, 1, 2, 5, 4}
f = [1, 3, 5, 7, 9] // {3, 9, 1, 5, 7}
g = [2, 4, 6, 8, 10] // {10, 2, 6, 4, 8}

// 차집합
result = e.subtracting(f)
e.subtract(f) // {6, 8, 2, 4}
```
